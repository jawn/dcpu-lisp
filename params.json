{"name":"dcpu-lisp","body":"dcpu-lisp is a simple Lisp-like language that compiles to optimized DCPU-16 assembly code. It is a very restricted subset of Lisp. There is no GC, and thus no data structures or run-time closures.\r\n\r\nThis is intended for usage in Mojang's next game, [0x10c](<http://0x10c.com/>).\r\n\r\n* Example program: https://github.com/jlongster/dcpu-lisp/blob/master/examples/print-number.l\r\n* Generated assembly: https://github.com/jlongster/dcpu-lisp/blob/master/examples/print-number.asm\r\n* Watch it run here: http://0x10co.de/imq63\r\n\r\n# High-level Assembly\r\n\r\nThink of it as a light wrapper around the assembly code, providing named variables, lexically-bound closures, and a little bit of helpful magic here and there.\r\n\r\nCreate a function like so:\r\n\r\n    (define (foo x)\r\n      (+ x 1))\r\n\r\nVariable references are statically referenced and compiled out straight to registers. In one function, you are not allowed more variable definitions than there are registers (7, and the 8th is used for the return value).\r\n\r\nNested functions are allowed:\r\n\r\n    (define (foo x)\r\n      (define (bar y)\r\n        (+ x y))\r\n      (bar 10))\r\n\r\nRun-time closures are not available because of the lack of GC, so the closed function cannot out-live its parent (you can't return `bar`).\r\n\r\nOnly 2 kinds of values exist: functions and 16-bit numbers.\r\n\r\nThere is a lot more we could do to enrich the language but still keep provable semantics statically.\r\n\r\nIt is written in Outlet, a Lisp that compiled to Javascript, so the compiler can run in browser. See https://github.com/jlongster/outlet. The js is packaged with the project so you can run it with Node.\r\n\r\n# Features\r\n\r\n* Named functions and variables\r\n* Nested functions\r\n* Inlinable arithmetic expressions\r\n* Inline assembly\r\n* Macros\r\n* Standard library for allocation, I/O, etc.\r\n* Probably other stuff I've forgotten about\r\n\r\n# Does Not Have\r\n\r\n* Garbage Collector\r\n* Heap\r\n* Run-time closures\r\n* Data types/structures\r\n* Type inference\r\n\r\n# Usage\r\n\r\nUse the `lcpu` script in the `bin` directory:\r\n\r\n`./bin/lcpu program.l`\r\n\r\nIt will print the generated assembly to standard output.\r\n\r\n    lcpu [-p] [-c1] [-c2] [-c3] [-l] [-e] <program/expression>\r\n\r\n    * -p: print the expanded program\r\n    * -c1: print the code after the first compilation phase\r\n    * -c2: print the code after the second compilation phase\r\n    * -c3: print the code after the third compilation phase\r\n    * -l: print the code after the linearization phase\r\n    * -e: run an expression instead of a file\r\n\r\nIf you get an error, you may have to run this: `touch compiler.ol && make`\r\n\r\n# Standard Library\r\n\r\nEventually, dcpu-lisp will target a specific operating system or programming environment in the DCPU-16 machine. I'm not interested in writing and maintaining custom memory allocation, I/O, and other libraries.\r\n\r\nUnfortunately, DCPU-16 is so new we don't really have any of those yet. However! A few awesome people have started to write them, along with libraries for things like allocation and I/O.\r\n\r\nWe've started bundling these basic libraries under a single project called [stdlib](https://github.com/0x10c-dev/stdlib). dcpu-lisp comes with this bundled in, so you can use it straight out of the box. The included procedures are:\r\n\r\n* ``(malloc owner length)``\r\n* ``(free ptr)``\r\n* ``(getline)``\r\n* ``(putc)``\r\n\r\nNOTE: I haven't added the interfaces by default yet, but view the [console example](https://github.com/jlongster/dcpu-lisp/blob/master/examples/console.l) to see how to use them.\r\n\r\n# Examples\r\n\r\nYou can see all the examples in the [examples](https://github.com/jlongster/dcpu-lisp/tree/master/examples>)\r\ndirectory.\r\n\r\n## Number Printing\r\n\r\nThis code defines `print-number` which prints a number to the console:\r\n\r\n    (define (print color bg-color x y text)\r\n      (MUL y 32)\r\n      (ADD y x)\r\n      (ADD y 0x8000)\r\n      (SHL color 12)\r\n      (SHL bg-color 8)\r\n      (BOR text color)\r\n      (BOR text bg-color)\r\n      (SET [y] text))\r\n\r\n    (define (%print-number n i)\r\n      (define (p n)\r\n        (print 0xf 0 (- 31 i) 0 (+ 0x30 n)))\r\n\r\n      (if (< n 10)\r\n          (p n)\r\n          (begin\r\n            (p (% n 10))\r\n            (%print-number (/ n 10) (+ i 1)))))\r\n\r\n    (define (print-number n)\r\n      (%print-number n 0))\r\n\r\n    (print-number 12345)\r\n\r\n## Fib\r\n\r\nHere is the fib program and the resulting assembly code (without the runtime, which just provides a few helpful functions). You can get the full assembly code in examples/fib.asm.\r\n\r\n    (define (fib a)\r\n      (if (<= a 1)\r\n          1\r\n          (+ (fib (- a 1))\r\n             (fib (- a 2)))))\r\n    \r\n    ;; result will be in register J\r\n    (fib 8)\r\n\r\nGenerated assembly:\r\n\r\n    JSR global_dash_entry\r\n    SET PC, __exit\r\n\r\n    :global_dash_entry\r\n    SET PUSH, return_dash_o1957346\r\n    SET PUSH, 0x8\r\n    SET PC, global_dash_entry_dash_fib\r\n    :return_dash_o1957346\r\n    SET PC, POP\r\n    :global_dash_entry_dash_fib\r\n    SET A, POP\r\n    SET PUSH, A\r\n    SET PUSH, return_dash_o3554470\r\n    SET PUSH, A\r\n    SET PUSH, 0x1\r\n    SET PC, global_dash__lt__eq_\r\n    :return_dash_o3554470\r\n    SET A, POP\r\n    IFE J, 0x0\r\n    SET PC, alt_dash_o5960250\r\n    SET J, 0x1\r\n    SET PC, exit_dash_o9848488\r\n    :alt_dash_o5960250\r\n    SET PUSH, A\r\n    SET PUSH, return_dash_o7693500\r\n    SET PUSH, A\r\n    SET PUSH, return_dash_o6022101\r\n    SET J, A\r\n    SUB J, 0x1\r\n    SET PUSH, J\r\n    SET PC, global_dash_entry_dash_fib\r\n    :return_dash_o6022101\r\n    SET A, POP\r\n    SET PUSH, J\r\n    SET PUSH, A\r\n    SET PUSH, return_dash_o8008109\r\n    SET J, A\r\n    SUB J, 0x2\r\n    SET PUSH, J\r\n    SET PC, global_dash_entry_dash_fib\r\n    :return_dash_o8008109\r\n    SET A, POP\r\n    SET PUSH, J\r\n    SET PC, _plus_\r\n    :return_dash_o7693500\r\n    SET A, POP\r\n    :exit_dash_o9848488\r\n    SET PC, POP\r\n    :__exit\r\n    SET PC, __exit\r\n\r\nYou can also view the tests in the `tests` directory to see how certain expressions are compiled.\r\n\r\n# Inline Assembly\r\n\r\nIf you want, you can code straight DCPU-16 assembly into your program. For example, here is a function that prints values to the console:\r\n\r\n    (define (print color bg-color x y text)\r\n      (MUL y 32)\r\n      (ADD y x)\r\n      (ADD y 0x8000)\r\n      (SHL color 12)\r\n      (SHL bg-color 8)\r\n      (BOR text color)\r\n      (BOR text bg-color)\r\n      (SET [y] text))\r\n\r\nDereferencing is supported with the normal bracket syntax (i.e. `[y]`).\r\n\r\n# Macros\r\n\r\n`define-macro` is provided for defining macros:\r\n\r\n    (define-macro (foo t x y)\r\n      `(begin\r\n         (define ,t (+ ,x ,y))\r\n         (MUL ,t 50)))\r\n\r\n    (foo z 1 2)\r\n\r\nis converted into:\r\n\r\n    (begin\r\n      (define z (+ 1 2))\r\n      (MUL z 50))\r\n\r\nThis is a powerful construct to make sure you can generate optimized assembly code.\r\n\r\n# Iteration\r\n\r\nThe `do` construct provides iteration. There are two versions of `do`:\r\n\r\n    ;; Runs the expression with x starting at 0 and incrementing by 1\r\n    ;; until it hits 32\r\n    (do (x 0 32)\r\n        (print (* x 20)))\r\n\r\n    ;; Or you can provide your own start, stepping and stopping\r\n    ;; expressions.\r\n    ;; Here x starts as 0, is incremented by 5 and continues looping while\r\n    ;; x is less than 100\r\n    (do (x 0 (+ x 5) (< x 100))\r\n        (print x)\r\n        (print (/ x 2)))\r\n\r\n\r\n# Future work (ABI refactoring, etc)\r\n\r\n## ABI\r\n\r\nI made up my own ABI, since I haven't really written assembly before. Now that I know more about it, and the 0x10c community seems to be converging on a [standard](https://github.com/0x10cStandardsCommittee/0x10c-Standards/tree/master/ABI), I need to refactor how I store data and pass it around.\r\n\r\nLuckily, you can just write code and not worry about all of that. When it changes, you'll just have to recompile.\r\n\r\n## Debugging\r\n\r\nIt's pretty painful to debug the code right now (although, its pretty painful to debug any assembly code). This could be another *huge* benefit to using dcpu-lisp: write an interpreter which runs code and lets you debug it on the fly. You could debug it easily and then compile it down when you're ready.\r\n\r\n## Optimizations\r\n\r\nThere are many more static optimizations we could do. I'm sure there are bugs in this too, as it is rather untested. Please report issues on github if you find any, or contact me at longster@gmail.com.\r\n\r\nFollow me on twitter: [@jlongster](http://twitter.com/jlongster)\r\n","tagline":"A Lisp-like language that compiles to DCPU-16 assembly code","google":"UA-31070259-1","note":"Don't delete this file! It's used internally to help with page regeneration."}