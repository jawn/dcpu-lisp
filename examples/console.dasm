; Generated by LCPU
; http://jlongster.github.com/dcpu-lisp/
; 
JSR entry
SET PC, __exit
:_gt__gt_
SET A, POP
SET B, POP
SET J, B
SHR J, A
SET PC, POP
:_lt__lt_
SET A, POP
SET B, POP
SET J, B
SHL J, A
SET PC, POP
:_per_
SET A, POP
SET B, POP
SET J, B
MOD J, A
SET PC, POP
:_slash_
SET A, POP
SET B, POP
SET J, B
DIV J, A
SET PC, POP
:_star_
SET A, POP
SET B, POP
SET J, B
MUL J, A
SET PC, POP
:_dash_
SET A, POP
SET B, POP
SET J, B
SUB J, A
SET PC, POP
:_plus_
SET A, POP
SET B, POP
SET J, B
ADD J, A
SET PC, POP
:_lt_
SET B, POP
SET A, POP
IFG A, B
SET PC, _lt__dash_ret
IFE A, B
SET PC, _lt__dash_ret
SET J, 0x1
SET PC, POP
:_lt__dash_ret
SET J, 0x0
SET PC, POP
:_lt__eq_
SET B, POP
SET A, POP
IFG A, B
SET PC, _lt__eq__dash_ret
SET J, 0x1
SET PC, POP
:_lt__eq__dash_ret
SET J, 0x0
SET PC, POP
:_gt_
SET B, POP
SET A, POP
IFG A, B
SET PC, _gt__dash_ret
SET J, 0x0
SET PC, POP
:_gt__dash_ret
SET J, 0x1
SET PC, POP
:_gt__eq_
SET B, POP
SET A, POP
IFG A, B
SET PC, _gt__eq__dash_ret
IFE A, B
SET PC, _gt__eq__dash_ret
SET J, 0x0
SET PC, POP
:_gt__eq__dash_ret
SET J, 0x1
SET PC, POP
:_eq_
SET B, POP
SET A, POP
IFE A, B
SET PC, _eq__dash_ret
SET J, 0x0
SET PC, POP
:_eq__dash_ret
SET J, 0x1
SET PC, POP
:entry
SET PUSH, return_dash_o5495440
SET PC, alloc_init
:return_dash_o5495440
SET PUSH, return_dash_o9107401
SET PC, entry_dash_main
:return_dash_o9107401
SET PC, __exit
;; Memory allocation.
;; by José Manuel Díez (jdiez)
;; licensed under MIT.
;;
;; http://u.jdiez.me/0x42c/kernel.html#x01e-kern-malloc
;; http://u.jdiez.me/0x42c/kernel.html#x022-kern-free
;; declares: malloc, free

:mem_start dat __end ; adjust these to your liking.
:mem_end dat 0       ; initialized in alloc_init

:alloc_init
    SET J, 0x1fff
    SET [mem_end], [mem_start+J]

    SET A, [mem_start]
    SET B, [mem_end]
    JSR set_initial_blocks
    SET PC, POP

; void* malloc(int words, int owner)
:malloc
    set i, [mem_start]
    set A, POP
    set B, POP
    
    :malloc_loop
        ife [i], 0xffff
            set pc, malloc_found_free
        
        add i, 1
        add i, [i]
        add i, 2
        
        set pc, malloc_loop
    :malloc_found_free
        ife i, [mem_start] ; beginning
            set pc, malloc_allocate
        
        add i, 1
        
        ife [i], a
            set pc, malloc_prepare
        ifg [i], a
            set pc, malloc_check_overhead
            
        add i, 1
        add i, [i] ; size of block
        
        set pc, malloc_loop    
        
    :malloc_check_overhead
        set push, b
        set b, [i]
        sub b, a
        ifg b, 3 ; plenty of space for overhead
            set pc, malloc_check_end
        
        sub i, 1
        set b, pop
        set [i], b ; it isn't worth dividing the space
        set push, i
        set pc, malloc_end
        
        :malloc_check_end
            set b, pop
            set pc, malloc_prepare    
        
    :malloc_prepare
        sub i, 1
        set pc, malloc_allocate
        
    :malloc_allocate
        set push, i
        set push, i
        set [i], b
        add i, 1
        set [i], a
        add i, 1
        add i, a
        set b, pop
        set [i], b ; header pointer
        
        add i, 1
        set a, i
        set b, [mem_end]
        jsr set_initial_blocks
        set pc, malloc_end
           
    :malloc_end
        set J, pop
        add J, 2 ; real start of memory
        set pc, pop

; void free(void* addr) 
:free
    set a, pop
    sub a, 2 ; user gives the first allocated word, header is two words back  
    set [a], 0xffff ; free memory
    set push, a
    
    :free_check_forward
        add a, 1
        set b, [a]
        add a, b
        add a, 2 ; next header
        ife [a], 0xffff
            set pc, free_merge_forward
    
    :free_check_backwards
        set a, peek
        sub a, 1
        ifg a, [mem_start]
            set pc free_check_backwards_continue
            
        set pc, free_end
    
    :free_check_backwards_continue
        ife [a], 0x0 ; if previous footer is empty
            set pc, free_end
        
        set b, [a]
        set a, b
        ifn [a], 0xffff
            set pc, free_end
            
        set peek, a ; the previous push is unnecesary
        add a, 1
        set b, [a]
        add a, b
        add a, 2 
                          
        set pc, free_merge_forward ; no need to check since we already know there's a blob of free memory there
        
    :free_merge_forward
        set [a], 0x0
        add a, 1
        set b, [a]
        set c, b ; previous block length
        set [a], 0x0
        add a, b
        ifn a, [mem_end]
            add a, 1 ; footer of this block
        set b, pop
        set push, b ; we'll need it at the end
        set [a], b
        set a, b
        add a, 1
        set b, [a]
        add b, c
        add b, 3 ; considering overhead
        set [a], b
        set pc, free_end
    
    :free_end
        set a, pop
        set pc, pop
        
; void set_initial_blocks(void memstart, void memend)    
:set_initial_blocks
    set push, b
    set [a], 0xffff ; owner of free mem
    add a, 1
    sub b, a
    set [a], b      ; space available
    set b, pop
    sub a, 1
    set [b], a
    
    set pc, pop


;; Memory helpers
;; by Michael Gerhaeuser (migerh, @migerh)
;; licensed under WTFPL. feel free to use.
;;
;; declares: memmove

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; memmove

; moves memory
;
;  A: source
;  B: destination
;  C: length
;
; cycles: ? (depends on C)
; receives: A, B, C
; clobbers: A, B, C
; returns:
:memmove
  SET C, POP
  SET B, POP
  SET A, POP

  ; src and dst are the same, nothing to do
  IFE A, B
    SET PC, POP
    
  ; move nothing
  ; thanks to Fisherman/reynir for pointing that one out
  IFE C, 0
    SET PC, POP
  
  ; default direction is forward
  SET PUSH, 0x1
  
  ; determine the direction
  IFG A, B
    SET PC, memmove_loop
    
  ; dst lies before the src, copy backwards
  SET [SP], 0xFFFF
  ; this is required to start at the right offset
  SUB C, 1
  ADD A, C
  ADD B, C
  ; correct the length
  ADD C, 1

:memmove_loop
  SET [B], [A]
  ADD A, [SP]
  ADD B, [SP]
  SUB C, 1
  IFN C, 0
    SET PC, memmove_loop
  ADD SP, 1
  SET PC, POP



;; Buffered Text I/O Primitives
;; by Kang Seonghoon (lifthrasiir, @senokay)
;; licensed under WTFPL. feel free to use.
;;
;; declares: newline, scroll, clear, putc, rawputc,
;;           getc, fillbuffer, getline

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; base screen routines

:screenoff
  ; keeps an offset to the current cursor.
  ; ranges from 0 to 0x17f; 0x180 causes the screen
  ; to scroll.
  DAT 0

; moves the cursor to the first letter of next
; line. automatically scrolls the screen.
;
; clobbers: C
:newline
  SET C, [screenoff]
  AND C, 0xffe0
  ADD C, 0x20
  SET [screenoff], C
  IFG 0x180, C
    SET PC, POP
  ; *falls through*

; scrolls the screen up by one line.
; 
; cycles: <= 1703
; clobbers: C
:scroll
  SET C, 0x8000
:scroll_copy
    SET [C], [C+0x20]
    SET [C+1], [C+0x21]
    SET [C+2], [C+0x22]
    SET [C+3], [C+0x23]
    ADD C, 4
    IFG 0x8160, C
      SET PC, scroll_copy
:scroll_fill
    SET [C], 0
    SET [C+1], 0
    SET [C+2], 0
    SET [C+3], 0
    ADD C, 4
    IFG 0x8180, C
      SET PC, scroll_fill
  SUB [screenoff], 0x20
  SET PC, POP

; entirely clears the screen.
;
; cycles: <= 1349
; clobbers: C
:clear
  SET C, 0x8000
:clear_loop
    SET [C], 0
    SET [C+1], 0
    SET [C+2], 0
    SET [C+3], 0
    ADD C, 4
    IFG 0x8180, C
      SET PC, clear_loop
  SET [screenoff], 0
  SET PC, POP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; putc, rawputc
;; depends: base screen routines

; writes one character to the current position.
; supports a newline character (when A=10).
; automatically scrolls the screen whenever needed.
;
; receives: A (character to be written)
; clobbers: A, C
:putc
  SET A, POP
  IFE A, 10
    SET PC, newline
  AND A, 0x7f
  BOR A, 0xf000
  ; *falls through*

; same as putc but does not process newlines.
; also does not strip color and blink bits.
;
; receives: A (word to be written)
; clobbers: A, C
:rawputc
  ; we need a room for a visible cursor in getc,
  ; so it is not 0x17f.
  IFG [screenoff], 0x17e
    JSR scroll
  SET C, [screenoff]
  SET [C+0x8000], A
  ADD C, 1
  SET [screenoff], C
  SET PC, POP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; getc
;; depends: base screen routines

; reads one character from the line buffer.
; line buffer is automatically filled as needed;
; the visible cursor will appear[*], the screen
; will scroll as needed, and the user can input
; any amount of text until the line buffer fills.
; backspace is supported as well.
;
; [*] currently implemented as XORing the cursor
;     position with 0xff00. may behave weirdly if
;     you are using a colored text; search for the
;     word "cursor" if you want to fix it.
; 
; the size of the line buffer is currently 128
; (including a newline character) but easily
; configurable. see lines commented with "BUFSIZE".
; be careful however: BUFSIZE should not exceed 352
; (=11*32) anyway!
;
; clobbers: A, B, C
; returns: A (read character)
:getc
  ; just consume the line buffer if any
  IFG [inputsize], [inputoff]
    SET PC, getc_buffered
  JSR fillbuffer
:getc_buffered
  SET B, inputoff
  SET A, [B]
  SET A, [A+inputbuf]
  ADD [B], 1
  SET PC, POP

; discards the line buffer and reads one line up to
; the next newline. for internal uses only.
:fillbuffer
  ; register uses:
  ; A = the current buffer size.
  ;     eventually dumped to [inputsize]
  ; B = the current character
  ; C = the current keyboard buffer position,
  ;     or the pointer to the current cursor
  ;
  ; C is clobbered by scroll and newline, but
  ; the code does not use C permanently anyway.
  SET A, 0
  SET C, [screenoff]
  ; draws the cursor
  XOR [C+0x8000], 0xff00
:fillbuffer_wait
    SET C, [keyoff]
:fillbuffer_busywait
      ; 3(!) cycles per iteration
      IFE [C], 0
        SET PC, fillbuffer_busywait
    ADD [keyoff], 1
    AND [keyoff], 0x900f
    SET B, [C]
    SET [C], 0
    IFE B, 10
      SET PC, fillbuffer_commit
    IFE B, 8
      SET PC, fillbuffer_bksp
    ; these things avoid problems with other events
    ; or punctuations (may have a high bit set)
    IFG B, 127
      SET PC, fillbuffer_wait
    IFG 32, B
      SET PC, fillbuffer_wait
    IFG A, 126  ; replace 126 with BUFSIZE-2
      SET PC, fillbuffer_wait
    SET [A+inputbuf], B
    SET C, [screenoff]
    BOR B, 0xf000
    ; will erase the cursor as well
    SET [C+0x8000], B
    ; see putc comment
    IFG C, 0x17e
      JSR scroll
    ADD [screenoff], 1
    SET C, [screenoff]
    ; draws the cursor
    XOR [C+0x8000], 0xff00
    ADD A, 1
    SET PC, fillbuffer_wait
:fillbuffer_bksp
    IFE A, 0
      SET PC, fillbuffer_wait
    SUB A, 1
    SET C, [screenoff]
    ; erases the cursor (cannot set to 0 since
    ; we keep the original screen contents as long
    ; as the line buffer does not overwrite it...)
    XOR [C+0x8000], 0xff00
    ; the previous position is replaced with
    ; an empty cursor
    SET [C+0x7fff], 0x0f20
    SUB [screenoff], 1
    SET PC, fillbuffer_wait
:fillbuffer_commit
  SET C, [screenoff]
  ; erases the cursor
  XOR [C+0x8000], 0xff00
  JSR newline
  SET [A+inputbuf], 10
  ADD A, 1
  SET [inputsize], A
  SET [inputoff], 0
  SET PC, POP

:keyoff
  DAT 0x9000
:inputoff
  DAT 0
:inputsize
  DAT 0
:inputbuf
  ; should have BUFSIZE zeroes here
  DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; getline
;; depends: getc (and base screen routines)

; reads one line (i.e. all remaining characters
; up to the next newline), trims a trailing
; newline and returns the line string.
; the string is valid until next getc or getline.
;
; clobbers: A, B, C
; returns: A (pointer to str), B (string length)
:getline
  ; fill the buffer first if it is empty
  IFG [inputsize], [inputoff]
    SET PC, getline_buffered
  JSR fillbuffer
:getline_buffered
  ; now the final character *has* to be a newline.
  ; ignore it and return the remainder.
  SET B, [inputsize]
  SET A, [inputoff]
  SET [inputsize], A
  SUB B, A
  SUB B, 1
  ADD A, inputbuf

  SET PUSH, A
  SET PUSH, B 

  SET PUSH, return-o12343
  SET PUSH, 0
  SET PUSH, B
  SET PC, malloc
:return-o12343

  SET B, POP
  SET A, POP

  SET PUSH, J

  SET PUSH, return-o324523
  SET PUSH, A
  SET PUSH, J
  SET PUSH, B
  SET PC, memmove
:return-o324523

  SET POP, J

  SET PC, POP

SET PC, POP
:entry_dash_ptr_dash_length
SET A, POP
SUB A, 0x1
SET J, [A]
SET PC, POP
:entry_dash_print_dash_line
SET C, POP
SET PUSH, C
SET PUSH, return_dash_o745739
SET PUSH, 0x0
SET PC, entry_dash_print_dash_line_dash_o9566955
:return_dash_o745739
SET C, POP
SET PUSH, C
SET PUSH, return_dash_o5176059
SET PUSH, 0xa
SET PC, putc
:return_dash_o5176059
SET C, POP
SET PC, POP
:entry_dash_print_dash_line_dash_o9566955
SET A, POP
SET PUSH, C
SET PUSH, B
SET PUSH, A
SET PUSH, return_dash_o6032806
SET PUSH, A
SET PUSH, C
SET PUSH, B
SET PUSH, A
SET PUSH, return_dash_o7510721
SET PUSH, C
SET PC, entry_dash_ptr_dash_length
:return_dash_o7510721
SET A, POP
SET B, POP
SET C, POP
SET PUSH, J
SET PC, _lt_
:return_dash_o6032806
SET A, POP
SET B, POP
SET C, POP
IFE J, 0x0
SET PC, alt_dash_o8209037
SET B, C
ADD B, A
SET PUSH, C
SET PUSH, B
SET PUSH, A
SET PUSH, return_dash_o3373995
SET PUSH, [B]
SET PC, putc
:return_dash_o3373995
SET A, POP
SET B, POP
SET C, POP
SET PUSH, C
SET PUSH, B
SET PUSH, A
SET PUSH, return_dash_o9880505
SET J, A
ADD J, 0x1
SET PUSH, J
SET PC, entry_dash_print_dash_line_dash_o9566955
:return_dash_o9880505
SET A, POP
SET B, POP
SET C, POP
SET PC, exit_dash_o864847
:alt_dash_o8209037
:exit_dash_o864847
SET PC, POP
:entry_dash_main
SET PUSH, return_dash_o4673635
SET PC, getline
:return_dash_o4673635
SET A, J
SET PUSH, A
SET PUSH, return_dash_o3545029
SET PUSH, A
SET PC, entry_dash_print_dash_line
:return_dash_o3545029
SET A, POP
SET PUSH, A
SET PUSH, return_dash_o5160831
SET PUSH, A
SET PC, free
:return_dash_o5160831
SET A, POP
SET PC, entry_dash_main
SET PC, POP
:__exit
SET PC, __exit
:__end
